# -*- coding: utf-8 -*-
"""DS_01_Introdução_ao_Python_Modalmais - Final.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ouo7d52Tvdrz0TXi33zT5w4i2-1fLjAa

# Data Science com Python

## Módulo 01 - Introdução ao Python

<center><img src="https://upload.wikimedia.org/wikipedia/commons/1/1f/Python_logo_01.svg" width="500">

## 0.Hello World!

Tradicionalmente no ensino de programação, inicia-se com o comando clássico "Hello World!"
"""

# Usando a função "print" para imprimir na tela a mensagem entre aspas

print("Hello World!")

"""## 1. Variáveis vs. Objetos

### 1.1. Tipos de variáveis
"""

3

a = 3

"""#### Tipos de variáveis

integer (int): 2
    
float: 1.45789
    
string (str): "PETR4"
    
boolean (bool): True ou False
"""

b = 5.5

b

print(b)

a + b

type(a)

type(b)

ativo = 'WEGE3'

ativo

type(ativo)

a == b

a = b

a

a == b

c = a == b

c

"""## 2. Operadores aritméticos

* Soma +
* Subtração -
* Multiplicação *
* Divisão /
* Divisão // (parte inteira)
* Resto das divisões
* Potência **
"""

d = a + b

d

e = d + a + b + d + d

e

a-b

e - d

a*b

f = 10

e*f

"""Exemplo

Qual o tamanho da minha posição em PETR4 dados o número de papéis que comprei e a cotação atual?
"""

cotacao = 33.32
papeis = 100

patrimonio = cotacao*papeis

"""Qual o preço atual?"""

patrimonio/papeis

"""Exemplo com VALE3 - qual o número de papéis que eu posso comprar?"""

carteira = 4000

vale3 = 50.32

carteira/vale3

carteira//vale3

10//4

"""Resto da divisão"""

7%4

10%3

"""Potenciação"""

2**2

2**3

2**10

"""## 3. Operadores lógicos

### 3.1. Operadores comparativos

* Igualdade ==
* Diferença !=
* Menor <
* Maior >
* Menor ou igual <=
* Maior ou igual >=
"""

e == f

e != f

e

f

e < f

e > f

g = 5
h = 5

g >= h

papel1 = "VALE3"
papel2 = "PETR4"

papel1 == papel2

papel1 != papel2

"""### 3.2. Operadores condicionais

* and
* or
"""

e > f and g >= h

e < f

e < f or g >= h

e < f or g > h

e < f and g >= h

"""## 4. Strings

### 4.1. Indexação e 'slicing' (fatiamento)
"""

# Suponha que você viu a seguinte manchete:

manchete = 'PETR4 vai aumentar o preço da gasolina'

print(manchete)

type(manchete)

# Comprimento (length) do objeto, nesse caso número de caracteres

len(manchete)

manchete[0]

manchete[1]

manchete[4]

manchete[5]

manchete[0:6]

acao = manchete[0:5]

acao

# Do caractere 5 até o fim
manchete[5:]

# Do início até o caractere 10 (sem retornar o 10)
manchete[:10]

# Do início até o fim

manchete[:]

# A operação de indexing (indexação) também pode começar 'de trás para frente'. Basta utilizar índices negativos.
manchete[:-8]

manchete[5:-8]

"""Agora, temos um segundo ':'

Ele indica de quantos em quantos caracteres devemos percorrer o intervalo
"""

# Neste caso, percorremos todo o intervalo, mas indo de -1 em -1 (ou seja, de trás para frente)
manchete[::-1]

manchete[::1]

acao[::-1]

manchete[5::-1]

"""string[a:b:c]

Resumindo o slicing:

Uma forma de definirmos as notações string[a:b:c] seria algo como: Execute um comando de fatiamento da string em intervalos de ‘c’, a partir de ‘a’ (incluso) até ‘b’ (não incluso). Se ‘c’ for negativo, contamos de trás para frente. Quando ‘c’ não está presente no código, o padrão é 1 (i.e., fatiar de 1 em 1 caractere). Se ‘a’ não está presente, então você começa o mais distante possível na direção que você está contando (i.e., se ‘c’ é positivo, começa no primeiro caractere. Se ‘c’ é negativo, começa no último caractere). Se ‘b’ não está presente, então você termina o mais distante possível na direção que está contando (i.e., se ‘c’ é positivo, termina no último caractere. Se ‘c’ é negativo, termina no primeiro caractere).

### 4.2. Propriedades das strings

* Imutabilidade
* Adição
* Modificação de upper e lower case
"""

manchete

manchete[4:5]

# Output é um erro, já que a string é imutável, ou seja, não consigo substituir o '4' pelo '3' em 'PETR4'
manchete[4:5] = '3'

# Da mesma forma, não conseguimos substituir mais de um caractere na string
manchete[0:5] = 'VALE3'

manchete + ' por causa da alta do petróleo'

complemento = ' por causa da alta do petróleo'

frase_completa = manchete + complemento

frase_completa

# Método lower: modifica todos os caracteres para minúsculos

minusculo = frase_completa.lower()

minusculo

# Método upper: transforma tudo em maiúsculo

maiusculo = minusculo.upper()

maiusculo

"""Separar as palavras dentro de uma string com o método 'split'"""

frase_separada = frase_completa.split()

frase_separada

frase_completa.split('v')

# Primeira palavra
frase_separada[0]

# Última palavra
frase_separada[-1]



"""## 5. Listas"""

# Listas são marcadas pelos colchetes e permitem alocação de itens (ou elementos) repetidos
# Estão entre os objetos mais fáceis de manipulação pois aceitam substituições, adições, repetições...

nomes = ['André', 'João', 'José']

nomes

type(nomes)

# Permitem misturar strings com números

lista_misturada = ['André', 'João', 'José', 30, 29, 28]

lista_misturada

type(lista_misturada)

# Listas seguem o mesmo padrão de indexação e slicing. Cada elemento é separado por ',' (vírgula)

type(lista_misturada[0])

# Note que o elemento de índice '3' (30) é um número inteiro

type(lista_misturada[3])

# Conseguimos criar novas strings resultantes de operações com outras strings, inclusive procedentes de listas

'Os aprovados foram ' + nomes[0] + ' e ' + nomes[2]

# Nesse caso, embora sejam números, estão entre aspas e portanto, são lidos como strings
lista = ['28','29','30']

lista[0]

type(lista[0])

'A minha idade é ' + lista[0]

lista[2]

# As listas são mutáveis, ao contrário das strings

lista[2] = '31'

lista

# Também são aditivas

nova_lista = nomes + lista

nova_lista

# Repetir a lista 2 vezes

nova_lista*2

# Adicionar um novo elemento à lista. Método 'append'

# Note que estou incluindo um item numérico (integer)

lista.append(30)

lista

type(lista[3])

# Método 'pop' remove o último item

lista.pop()

lista

lista.pop()

lista

#Lista apenas com itens númericos

idade = [4, 54, 65, 34, 29, 78, 38]

# Método sort para classificar por ordem crescente (no caso de strings será por ordem alfabética)

idade.sort()

idade

# Método reverse para classificar por ordem decrescente (ordem alfabética invertida)

idade.reverse()

idade

# Criar três listas

lista1 = [0,1,2]
lista2 = [4,5,6]
lista3 = [7,8,9]

# Unir as três listas em uma lista só (lista de listas)

matriz = [lista1, lista2, lista3]

matriz

# Acessar a lista indexada como 1 (segunda lista) e seu item 0 (primeiro item)

matriz[1][0]

# Primeira lista e primeiro elemento

matriz[0][0]

"""## 6. Dicionários

Os dicionários representam uma estrutura de dados mais complexos que as listas, capazes de relacionar pares de dados (um dado que pode representar outro dado). Ao invés de colchetes, como as listas, são definidos pelas chaves. Em outras linguagens, poderia ser relacionado às "arrays associativas". A estrutura básica dos dicionários é "{*key: value*}"
"""

precos = {'PETR4':30,
          'VALE3': 102,
          'WEGE3': 34}

precos

type(precos)

# Listar apenas as chaves (keys) do dicionário

precos.keys()

# Listar apenas os valores do dicionário

precos.values()

# Listar os pares de itens do dicionário

precos.items()

# Indexação é feito pelas chaves e não pelos índices numéricos (como listas)

precos['PETR4']

precos['VALE3']

# Os dicionários são bem flexíveis quanto aos "values". Poderia ser uma string, uma lista...

precos = {'PETR4':'30',
          'VALE3': [102,103,104,105],
          'WEGE3': 34}

precos['PETR4']

precos['VALE3']

# São mutáveis, assim como as listas

precos['WEGE3'] = 30

precos

# Também permitem adição de novos itens

precos['GOAU4'] = 20

precos

listas = []

dicionarios = {}

"""## 7. Tuplas

As tuplas são criadas utilizando parênteses. Indexação e slicing similares aos de strings e listas. Estão entre as estruturas de dados mais simples (ex., são imutáveis e nao permitem adições), porém com pouca flexibilidade.
"""

tupla = ()

# Exemplo de uma tupla (permite valores repetidos)

tupla1 = (1,1,2,2,4,6,15)

tupla1

type(tupla1)

# Comprimento da tupla = número de itens

len(tupla1)

# Indexação similar a listas

tupla1[2]

# Fatiamento similar às listas e strings

tupla1[2:6]

# Tuplas possuem alguns métodos simples, como determinar o índice referente a um item específico (itens repetidos retornarão o índice do primeiro item)

tupla1.index(15)

tupla1.index(1)

# Método contagem de itens iguais

tupla1.count(15)

# Elas são imutáveis

# Este comando vai resultar em erro

tupla1[0] = 3

tupla1[0]

"""## 8. Conjuntos

Um conjunto (*set*), assim como a tupla, é criado utilizando parênteses. Não existe indexação ou slicing, ou seja, não seguem uma ordem (nesse caso mais similares aos dicionários). Permitem adições mas não permitem itens repetidos.
"""

# Cria-se um conjunto a partir da função set()

conjunto1 = set()

conjunto1

type(conjunto1)

# Método add para adicionar um novo item

conjunto1.add(9)

conjunto1

# Não consideram itens repetidos (pode ser usado para remover duplicatas)

# Veja que vamos adicionar o mesmo número várias vezes, mas ele os contabiliza apenas uma vez

conjunto1.add(9)
conjunto1.add(9)
conjunto1.add(9)
conjunto1.add(1)
conjunto1.add(1)
conjunto1.add(2)
conjunto1.add("PETR4")

conjunto1

len(conjunto1)

# Não são indexáveis, ou seja, não seguem uma ordem como as listas ou tuplas

# Portanto, este comando vai resultar em erro

conjunto1[0]

"""## 9. Declarações condicionais

Em linguagens de programação, frequentemente devemos criar estruturas e comandos para atuar de acordo com condições específicas, ou seja, apenas se alguma condição for satisfeita.
"""

# Exemplo: Determinar o preço atual de um ativo e o seu preço alvo de compra

preco_azul = 35.28
preco_alvo = 30

# Comando if ("se", em portugues), estabelecendo uma declaração condicional. Importante destacar a indentação das declarações
# elif é uma contração do else if

if preco_azul < 30:
    print('Compre, preço muito descontado!')
elif preco_azul < 33:
    print('Ainda em tendência de queda, espere um pouco mais!')
elif preco_azul <= 36:
    print('Iniciou tendência de queda, espere cair até 30')
else:
    print('Espere!')

preco_weg = 19

preco_alvo = 33

# Ressaltando a estrutura da declaração condicional -> if seguido da condição e ":" no fim. 
# Na linha seguinte, identação e comando caso a condição seja verdadeira 

if preco_weg > preco_alvo:
    print('Espere')
else:
    print('Compre!')

# Importante observar que as condições vão sendo checadas pela ordem em que foram declaradas. 
# Assim que uma delas é satisfeita, as demais não são executadas mais

if preco_weg < 25:
    print('Compre, preço muito descontado!')
elif preco_weg < 30:
    print('Ainda em tendência de queda, espere um pouco mais!')
elif preco_weg <= 32:
    print('Iniciou tendência de queda, espere cair até 25')
else:
    print('Espere!')

# Trocando a ordem das declarações. Note que assim que atendeu a primeira, as demais são ignoradas

if preco_weg < 30:
    print('Ainda em tendência de queda, espere um pouco mais!')
elif preco_weg < 25:
    print('Compre, preço muito descontado!')
elif preco_weg <= 32:
    print('Iniciou tendência de queda, espere cair até 25')
else:
    print('Espere!')

"""## 10. Estruturas de repetição

Além das estruturas (ou declarações) condicionais, as estruturas de repetição são muito importantes na sintaxe de qualquer linguagem de programação. Imagine que você queira automatizar uma tarefa, informando que ela deve ocorrer por determinadas vezes ou até que outra alguma outra condição seja estabelecida

### 10.1. For
"""

lista = ['João', 'José', 'Andre', 'Marcos']

# Para cada item dentro da lista, imprima o item. Essa automação também é conhecida como loop

for item in lista:
    print(item)

# Embora tenha usado a palavra item, o Python compreende que estou determinando elementos/itens de uma lista. Assim, poderia utilizar qualquer "nome" para descrever esses itens

for proprietario_automovel in lista:
    print(proprietario_automovel)

lista_ativos = ['PETR4.SA', 'WEGE3.SA', 'MGLU3.SA', 'LREN3.SA', 'RENT3.SA', 'VALE3.SA']

lista_ativos

# Criando uma automação para que pegue cada item da lista e adicione a frase "é um ativo da B3".
for acoes in lista_ativos:
    print(acoes,"é um ativo da B3")

# Automação usando a função break para interromper o loop assim que uma condição for satisfeita (integrando 'for' e 'if').
# Atenção à identação correta

for acoes in lista_ativos:
    print(acoes,"é um ativo da B3")
    if acoes == "LREN3.SA":
        break

for acoes in lista_ativos:
    print(acoes,"é um ativo da B3")
    if acoes == "WEGE3.SA":
        break

precos = {'PETR4':30,
          'VALE3': 102,
          'WEGE3': 34}

len(precos)

for i in range(0,len(precos)):
    print(list(precos.keys())[i],"está com o preço de",list(precos.values())[i],"neste momento")

"""### 10.2. While

A estrutura do while (enquanto, em português) se refere a outra repetição (loop) que ocorrerá enquanto a condição for verdadeira. Poderia ser pensada de uma maneira análoga ao uso do 'for' e 'if' integrados.
"""

preco_weg = 30

# Enquanto o preço for menor que 39, imprima a frase "Ainda não atingiu o preço alvo, espere. O preço atual é: ", junto com o preço atual. Além disso, multiplique o valor atual por 1.01
# Caso a condição pare de ser verdadeira (preço_weg seja >= 39) imprima esta outra frase: "Preço alvo atingido, hora de vender! Preço da venda: " junto com o preço atual

while preco_weg < 39:
    print("Ainda não atingiu o preço alvo, espere. O preço atual é: ", round(preco_weg,2))
    preco_weg = preco_weg*1.01

else:
    print("Preço alvo atingido, hora de vender! Preço da venda: ", round(preco_weg, 2))

# Outro exemplo de uso do while. Imagine que tem disponível 10000 reais para investir. A cada operação, sera computado o valor alocado nesta operação (cahamremos de "investimento_unitario") e o total já investido ("investimento_total")
# A função input interage com o usuario, recebendo um objeto (numérico, string...) e armazenando em uma variável. 

investimento_unitario = 0 
investimento_total = 0

# Enquanto o valor alocado for menor que 10000 a condição do while será executada. Quando essa condição não for mais verdadeira (no caso, investimento_total >= 10000), execute o que foi determinado no else
while investimento_total < 10000:
    investimento_unitario = int(input("Digite o valor investido na operação: "))
    investimento_total = investimento_total + investimento_unitario

else:
    print("Limite total previsto para investir foi atingido!")
    print("Você excedeu ", investimento_total-10000, " do valor previsto")

print("Você investiu o total de R$", investimento_total)

"""## 11. Alguns outros operadores

Alguns operadores são muito úteis para execução de estruturas condicionais e de repetição. Dentre eles:

### 11.1. Range

Indica um intervalo entre dois números. Segue o padrão da indexação (primeiro argumento inclusivo e segundo argumento não inclusivo)
"""

# Intervalo entre 0 (inclusivo) e 11 (exclusivo)
# O output não lista todos os números, reduzindo gastos com memória

range(0,11)

# Nessa caso, listará todos os elementos

list(range(0,11))

# Compreende todo o intervalo sequencial

for carros in range(0,11):
    print(carros)

# Também pode ser usado especificando um intervalo entre os números dentro do intervalo estabelecido, similar ao slicing

for i in range(0,11,2):
    print(i)

"""### 11.2. Enumerate

Função que transforma uma coleção de dados (lista, tupla, string) em um objeto enumerado de cada item da coleção
"""

lista_ativos = ['PETR4.SA', 'WEGE3.SA', 'MGLU3.SA', 'LREN3.SA', 'RENT3.SA', 'VALE3.SA']

# O output não enumera todos os itens, reduzindo gastos com memória

enumerate(lista_ativos)

# Nessa caso, irá enumerar todos os elementos

list(enumerate(lista_ativos))

# Podemos começar a enumeração a partir de outro número que não o 0

list(enumerate(lista_ativos,3))

# Exemplo usando uma string

acao = 'PETR4'

list(enumerate(acao))

for i, letra in enumerate(acao):
    print("No índice", i, "o caractere é", letra)

# Note que neste caso, o enumerate fez a mesma função da estrutura 'for' a seguir
index_count = 0

for letra in acao:
    print("No índice", index_count, "o caractere é", letra)
    index_count += 1

"""### 11.3. Zip & in

A função *zip* consegue executar interações entre listas. O operador *in* (dentro/pertencente em português) permite a leitura sequencial de objetos zip (assim como de listas), fundamental nas estruturas 'for'
"""

acoes = ['PETR4', 'WEGE3', 'MGLU3', 'JHSF3', 'GOAU4']
setores = ['Petróleo', 'Motores', 'Varejo', 'Construção', 'Metalurgia']

# Criar uma relação entre as duas listas acima. Output reduzido assim como os anteriores range e enumerate

zip(acoes, setores)

# Note que é uma lista de tuplas

list(zip(acoes, setores))

# Leitura sequencial do zip usando o in

for acao, setor in list(zip(acoes, setores)):
    print('O papel', acao, 'pertence ao setor', setor)

# Mostrando o operador f'', que será útil no exemplo seguinte
# Esse operador admite que usemos variáveis dentro das aspas, desde que essas variáveis estejam por sua vez dentro
# de chaves, como no exemplo abaixo

papel = 'PETR3'
setor = 'Petróleo'

f'A {papel} está no setor de {setor}'

# Uma outra forma de escrever o mesmo loop acima, desta dez usando o operador f''

for acao, setor in list(zip(acoes, setores)):
    print(f'O papel {acao} pertence ao setor {setor} ')

# Além de leitura sequencial, o in pode ser usado como operador lógico

'VIVR3' in acoes

'WEGE3' in acoes

"""### 11.4. Random

Este operador pode ser utilizado para obter números aleatórios de acordo com alguma condição pré-determinada
"""

from random import randint, shuffle

"""A função randint() retorna um número aleatório dentro de um intervalo específico"""

randint(0,100)

# Vamos gerar uma lista com 10 números aleatórios que sejam entre 10 e 100

lista_rand = []

for i in range(0,10):
    lista_rand.append(randint(0,100))

lista_rand

# Utilizando o operador shuffle para 'embaralhar' os números
shuffle(lista_rand)

lista_rand

"""### 11.5. min e max

Funções para retornar os valores mínimo e máximo de uma lista
"""

min(lista_rand)

max(lista_rand)

"""### 11.6. input

Função que permite que o usuário inpute algum valor de acordo com o que é pedido por um texto e armazene isso na memória de uma variável
"""

acao = input('Por favor insira a ação que deseja comprar: ')

acao

print(f'O cliente deseja comprar o papel {acao} ')

"""## 12. List Comprehension (Compreensão de Lista)

Forma de executar loops com uma estrutura de código mais resumida do que os "for" tradicionais
"""

acao = 'MGLU3'

"""Imagine que precisamos realizar a tarefa de transformar cada caractere na string acima em um item separado dentro de uma nova lista.

Como feríamos isso com nosso conhecimento em Python até agora?

**Exemplo 01**

Na forma tradicional usando "for", faríamos assim:
"""

lista_caracteres = []

for caractere in acao:
    lista_caracteres.append(caractere)

lista_caracteres

# Podemos usar o indexing para retornar algum caractere específico

lista_caracteres[1]

"""E como fazer isso utilizando a compreensão de lista?"""

# Perceba que o comando ficou bem mais simples

[caractere for caractere in acao]

"""O output da compreensão de lista é uma nova lista

**Exemplo 02**

Imagine que você recebeu uma série de tickers que vieram incompletos. Antes de realizar sua rotina, precisa adicionar um número '3' aos nomes dos papéis. Como você faria?
"""

ativos = ['MGLU', 'VALE', 'WEGE', 'LREN']

# Criamos uma lista vazia que será populada com os novos nomes dos ativos
novos_ativos = []

# Para cada ativo, vamos adicionar o caractere '3' no final
for letra in ativos:
    novos_ativos.append(letra + '3')

novos_ativos

"""Podemos realizar essa tarefa com uma compreensão de lista de uma forma mais rápida."""

[letra + '3' for letra in ativos]

"""**Exemplo 03**

Imagine que quiséssemos elevar todos os números de 0 a 10 ao quadrado.

Da forma tradicional, faríamos:
"""

list_num = []

for num in range(0,11):
    list_num.append(num**2)

# Resultado

list_num

"""Com a compreensão de lista, podemos fazer"""

[num**2 for num in range(0,11)]

"""## 13. Funções e métodos

Uma função é um comando capaz de realizar uma tarefa, de acordo com critérios que determinamos.

A função só é executada de fato quando é chamada, e executa atividades que foram especificadas pelo usuário.

Por exemplo: abaixo estamos criando uma função chamada "tempo_hoje", que é executada quando chamada. Seu propósito é imprimir a mensagem "Hoje faz sol" quando chamada.
"""

def tempo_hoje():
    print("Hoje faz sol")

tempo_hoje()

"""Vamos criar agora uma nova função que vai retornar a soma de dois números, sendo estes determinados pelo usuário."""

# Perceba que a função abaixo recebe dois arguentos: num1 e num2. A função vai então somar num1 e num2 e retornar o resultado desta soma.

def soma_numeros(num1, num2):
    soma = num1 + num2
    return soma

"""Vamos passar nessa função os números 2 e 3"""

soma_numeros(2, 3)

novo_objeto = soma_numeros(1000, 3050)

novo_objeto

"""Vamos criar agora uma nova função chamada "preco" que basicamente retorna a cotação de um papel, de acordo com o que for especificado pelo usuário."""

def preco(acao):
    if (acao == 'PETR4'):
        print('O preço agora é R$ 30,89')
    elif (acao == 'VALE3'):
        print('O preço agora é R$ 112')
    elif (acao == 'WEGE3'):
        print('O preço agora é R$ 32')
    elif (acao == 'MGLU3'):
        print('O preço agora é R$ 6,79')
    else:
        print('Papel desconhecido')

preco('PETR4')

preco('MGLU3')

"""Criando Docstring da função

O que é?

"Docstring" é a documentação da função, ou seja, a mensagem que aparece quando o usuário consulta a ajuda da função.
"""

def preco(acao):
    
    ''' ESSA FUNÇÃO DEVE SER UTILIZADA PARA RETORNAR A COTAÇÃO EM TEMPO REAL DE UM PAPEL '''

    if (acao == 'PETR4'):
        print('O preço agora é R$ 30,89')
    elif (acao == 'VALE3'):
        print('O preço agora é R$ 112')
    elif (acao == 'WEGE3'):
        print('O preço agora é R$ 32')
    elif (acao == 'MGLU3'):
        print('O preço agora é R$ 24,59')
    else:
        print('Papel desconhecido')

"""### Métodos

Métodos são funções aplicáveis apenas a determinados tipos de objetos. Todos os métodos são funções, mas nem todas as funções são métodos. Os métodos são executados ao fim dos objetos e separados com um ponto.
"""

numeros = [1, 2, 4, 6, 10]

"""Perceba que a função append() abaixo é um método."""

numeros.append(5)

numeros

"""## 14. Funções embutidas

Também conhecidas como "built-in functions" são funções nativas do Python que não necessitam de nenhuma biblioteca para sua execução.

### 14.1. Map

A funçã map() aplica um comando (função) a vários elementos de uma lista, de uma vez.

Confira alguns exemplos:
"""

def potencia(num, pot = 2):
    return num**pot

potencia(3)

potencia(3, 4)

lista_numeros = [1, 2, 3, 4, 5]

list(map(potencia, lista_numeros))

"""### 14.2. Filter

De forma análoga, a função "filter" aplica um filtro a vários elementos de uma lista de uma só vez.
"""

# Vamos criar uma função que retorna uma condição lógica, dizendo se um número é par (True) ou não (False)

def checar_par(num):
    return num%2 ==0

checar_par(2)

checar_par(9)

"""Se aplicarmos essa função à lista criada no item anterior, ela vai trazer apenas os números que são pares."""

list(filter(checar_par, lista_numeros))

"""## 15. Funções anônimas: lambda

São funções que não precisam de definição forma (explícita) podendo ser chamadas em apenas uma linha.

Suponha que queremos criar uma função que eleva os números ao quadrado:
"""

def quadrado(num):
    return num**2

quadrado(5)

"""Com o comando lambda, não precisamos dar um nome a essa função nem defini-la, basta especificar qual a tarefa que precisamos executar"""

lambda num: num**2

"""Caso seja do nosso interesse, podemos criar uma variável que recebe a operação realizada pela função lambda."""

quadrado_lambda = lambda num: num**2

quadrado_lambda(5)

"""Podemos ir ainda mais longe, aplicando essas funções a vários elementos de uma lista, com as funções **map** e **filter**"""

list(map(lambda num: num**2, lista_numeros))

list(filter(lambda num: num%2 ==0, lista_numeros))

"""## 16. Escopo das variáveis

Podemos entender o escopo como a "área de atuação" de uma variável.
"""

# escopo global

x = 25

def printer():
    x = 50
    return x

x

printer()

"""## 17. Args

Imagine que criamos uma função nova e especificamos a quantidade de argumentos que precisam ser passados nessa função:
"""

# Neste caso estamos criando uma função que recebe três argumentos: a, b e c

def soma_varios(a,b,c):
    soma = sum((a,b,c))
    return soma

soma_varios(1,2,3)

# Com 5 argumentos

def soma_varios(a,b,c,d,e):
    soma = sum((a,b,c,d,e))
    return soma

soma_varios(1,2,3,4,5)

# E num caso de ter N argumentos (número indefinido), como seria?
# Graças ao argumento *args, podemos dar a opção da função receber inúmeros argumentos

def soma_varios(*args):
    soma = sum(args)
    return soma

soma_varios(1)

soma_varios(1,2,3)

soma_varios(1,2,3,4,5,6,7,8,9)

"""## 18. Kwargs

De forma análoga ao *args, o **kwargs torna a função capaz de receber argumentos que tem um nome
"""

# No caso abaixo, o nome do argumento é 'acao'

def compra_de_acoes(**kwargs):
    if 'acao' in kwargs:
        print('A ação comprada foi ', kwargs['acao'])
    else:
        print('O cliente não investe em ações')

compra_de_acoes(acao = 'PETR4')

compra_de_acoes()

# No caso abaixo, temos dois argumentos do tipo kwargs que pedem um nome: 'acao' e 'lote'

def montagem_posicao(*args,**kwargs):
    if 'acao' and 'lote' in kwargs:
        print('O cliente montou uma posição de ', ' e '.join(kwargs['acao']))
        print('Ele comprou ', ' e '.join(args), 'papéis, respectivamente')
        print('Todas elas foram compradas no lote', kwargs['lote'])

montagem_posicao('100', '200', acao = ('PETR4', 'VALE3'), lote = 'inteiro')

"""## 19. Trabalhando com bibliotecas

1. O que são bibliotecas
2. Importância de se utilizar bibliotecas

### 19.1. Importando as bibliotecas

Nessa seção, vamos estudar as duas bibliotecas mais importantes do Python: pandas e numpy
"""

import numpy as np
import pandas as pd

"""### 19.2. Numpy

O principal tipo de objeto que criamos com a numpy é o 'array'

Para criar arrays, temos diversas funções diferentes, cada um servido a um propósito específico

Por exemplo, podemos criar arrays que contém apenas zeros
"""

a = np.zeros(3)

a

# O atributo .shape retorna as dimensões do array

a.shape

# As dimensões são manipuláveis. Logo, podemos especificar o número de linhas e colunas:

a.shape = (3, 1)

a.shape

a

"""Vamos criar um array contendo apenas '1'"""

b = np.ones(10)

b

# Array vazio

c = np.empty(4)

# veja que mesmo sendo próximo a 'vazio', os elementos da lista são não-nulos
c

# Podemos criar um array determinando início, fim e número de componentes

d = np.linspace(3, 15, 10)

d

# Podemos especificar manualmente os elementos do array

e = np.array(10)

e

f = np.array([1,2,3,4,5])

f

# Uma lista pode virar um array!

lista = [4,5,6,7,8,9]

g = np.array(lista)

g

type(g)

lista_listas = [[1, 2, 3, 4, 5], [4, 5, 6, 7, 8]]

# Podemos usar mais de uma lista na construção do array:

h = np.array([lista_listas])

h

np.random.seed(0)

i = np.random.randint(10, size = 6)

i

"""Podemos realizar indexação e slicing nos arrays:"""

i[0]

i[3]

i[-1]

"""Muito parecido com listas

Operações matemáticas
"""

a = np.array([10,20,100,200,500])
b = np.array([3,4,5,6,7])

np.add(a, b)

a + b

np.subtract(a, b)

a - b

np.multiply(a, b)

a*b

np.divide(a,b)

a/b

"""### 19.3. Pandas

Mostrar aqui como baixar os dados de WEGE3 do Yahoo Finance

Temos um arquivo .csv que foi disponibilizado junto com o material do curso
"""

dados = pd.read_csv('WEGE3.SA.csv')

"""Com o atributo shape podemos verificar as dimensões"""

dados.shape

"""Com o atributo dtypes podemos verificar o tipo das variáveis"""

dados.dtypes

# Tipo do objeto dados

type(dados)

# O método head() permite ver as 5 primeiras linhas

dados.head()

# O método tail() permite ver as 5 últimas linhas

dados.tail()

# Usamos o comando .loc para filtrar pelo index

dados.loc[0]

dados.iloc[0]

# Além de filtrar uma linha, podemos filtrar células

dados.iloc[0,0]

# Ou podemos filtrar colunas de nome específico

dados['Open']

# Podemos plotar apenas uma coluna

dados['Close'].plot()

dados.Close.plot()

# Podemos plotar um segmento de uma coluna. No exemplo abaixo, estamos plotando da linha 0 até a 500.

dados.iloc[0:500].Close.plot()

# Abaixo, estamos passando os valores da coluna 'Date' para o índice, 
# de tal forma que o índice do dataframe se torne a própria data

dados.index = dados.Date

dados.head()

# Isso nos permite agora filtrar linhas de acordo com uma data específica

dados.loc['2017-07-24']

"""Vamos trabalhar agora com diretórios diferentes"""

import os

"""Qual o diretório que estamos trabalhando neste momento?"""

os. getcwd()

# Caso você estivesse trabalhando com o Jupyter, ou algum outro IDE na sua máquina
os.chdir('/tmp')

"""Como renomear e renomear colunas"""

dados.rename(columns={'Date': 'Data', 'Adj Close': 'WEGE3'}, inplace=True)

dados.head()

# Removendo colunas

dados.drop(['Data', 'Volume'], axis = 1, inplace = True)

dados.head()

# Plotando todas as colunas

dados.plot()

"""Quantas linhas e colunas tem o dataframe?"""

dados.shape

"""Filtrando apenas algumas linhas específicas"""

dados.iloc[943:994].plot();

"""Aumentando o tamanho do gráfico"""

dados.iloc[943:994].plot(figsize = (10,10));